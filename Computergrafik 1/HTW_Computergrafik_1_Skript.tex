\newcommand{\customDir}{../}
\input{\customDir _LaTeX_master/LaTeX_master_setup.sty}

%\setboolean{twosided}{true}
%\setCustomDocumentClass{scrartcl}
%\setCustomDesign{htw}
\setCustomSlidePath{Vorlesung/CG1-01-15-neu}

\setCustomTitle{Computergrafik 1}
\setCustomSubtitle{Vorlesungsskript}
\setCustomAuthor{Falk-Jonatan Strube}
%\setCustomNoteA{TitlepageNoteBeforeAuthor}
\setCustomNoteB{Vorlesung von Prof. Dr.-Ing. habil. Oertel}

%\setcustomSignature{\footnotesize{\textcolor{darkgray}{Mitschrift von\\ \customAuthor}}	% Formatierung der Signatur in der Fußzeile
%\setcustomTitleAuthor{\textcolor{darkgray}{Mitschrift von #1}}	% Formatierung des Autors auf dem Titelblatt

\input{\customDir _LaTeX_master/LaTeX_master.sty}
\input{\customDir _LaTeX_master/LaTeX_master_macros.sty}

%\bibliography{\customDir _Literatur/HTW_Literatur.bib}

\begin{document}

%\selectlanguage{english}
\maketitle
\newpage
\tableofcontents
\newpage

\unimptnt{
\chapter*{Vorbemerkung}
Prüfung: alle Unterlagen erlaubt (Skripte, Bücher usw.)\\
2 Teile: 1/2 Praxis (erste Hälfte der VL), 1/2 „Theorie“ (zweite Hälfte der VL)\\
Belegabgabe: Ende der Vorlesungszeit (03.02.2016), Vorabgabe (vorm Einreichen) im Praktikum
% Passwort: WSEM2016
%\slide{2}

Folien mit +: wichtige Folien
\chapter*{Grundbegriffe}
\slide{3}
}
\section*{Systematisierung}
\slide{4}

\chapter{OpenGL: Anwendung und Programmierung}
\unimptnt{\slide{5}
\section{Systemarchitektur}
\slide{6}
\subsection{Interaktive generative grafische Systeme}
\slide{7}
\subsection{Grafische Datenstrukturen}
\slide{8}
\subsection{Weg und Ziel}
\slide{9}
3. Bild: Schattierung (keine Schattenbildung, sondern „Einfärbung“ von Seiten)
}
\section{OpenGL}
\slide{10}
\unimptnt{
\subsection{Versionen}
\slide{11}
\subsection{OpenGL Core Profile}
\slide{12}
Eckpunkte -> Vertex Shader -> Fragment Shader -> Framebuffer
}
\subsection{Grafik-Bibliotheken}
\slide{13}
\subsection{Initialisierung}
\slide{14}

\section{Renderpipeline}
\slide{15}
\subsection{Sequentielle Struktur}
\slide{16}
\unimptnt{
\slide{17}
}
\section{Rahmenprogramm}
\subsection{Client-Seite}
\slide{18}
\slide{19}
\subsection{Server-Seite}
\slide{20}

\section{Hauptprogramm}
\subsection{Sprachsyntax}
\slide{21}

\section{Funktionsreferenz}
\subsection{Funktionen GL}
\slide{22}
\unimptnt{
\slide{25}
}
\subsection{Funktionen GLUT}
\slide{23}
\unimptnt{
\slide{24}
}

\chapter{OpenGL: Shader und Programmierung}
\unimptnt{
\slide{28}
}
\section{Vorgehensweise}
\slide{29}
Fragment-Shader als Rasterisierung eines Bildes (bspw. Vektor-Strich von A nach B) und dann Zuweisung der Farbe den entsprechenden Rasterelementen/Pixel\\
Vertex-Shader guckt sich dem entgegen Eckpunkte an.
\section{Shader-Einbindung}
\slide{30}
\subsection{Programmbeispiele}
\slide{32}
\unimptnt{
\subsection{Funktionen}
\slide{31}
}

\section{Rasterisierung und obligatorischer Shader}
\unimptnt{
Aufgabe: Behandlung und Verarbeitung von Eckpunktdaten und Pixeldaten sowie deren Überführung
ineinander; Transformation zwischen Hauptprogramm und Frame Buffer.
\subsection{Rasterisierung}
\slide{33}
}
\subsection{Vertex-Shader}
\slide{34}
\subsection{Fragment-Shader}
\slide{35}
\unimptnt{
\subsection{Beispiele}
\slide{36}
}

\section{Shader-Sprache}
\slide{37}
\subsection{Operatoren und Ausdrücke}
\slide{38}
\slide{39}
\subsection{Qualifikatoren}
\slide{40}
\slide{41}
\slide{42}

\subsection{Vordefinierte Funktionen}
\slide{43}
\slide{44}

\subsection{Vordefinierte Variablen}
\slide{45}
\slide{46}

\subsection{Programmbeispiele}
\slide{47}
\slide{48}

\section{Programm- und Datenübergabe}
\unimptnt{
\slide{49}
}
\subsection{Interface Blöcke}
\slide{50}
\unimptnt{
\section{Funktionsreferenz}
\slide{51}
\slide{52}
}

\chapter{OpenGL: Zeichnung und Daten}
\unimptnt{
\slide{54}
}

\section{Vorgehensweise}
\slide{55}

\section{Zeichenprimitive}
\slide{56}

2,5\,D Geometrie: die 3. Dimension nur senkrecht zu einer Fläche (bspw. Bildschirm)

\subsection{Punkte, Linien}
\slide{57}

\subsection{Dreiecke}
\slide{58}

\subsection{Darstellungsattribute}
\slide{59}

\subsection{Programmeinbindung der Zeichenprimitive}
\subsubsection*{Befehlsfolge:}
\slide{60}

\section{Zeichenfarben}
\slide{61}
zeigt NUR im Fragmentshader Wirkung
\subsection{Farbe als Attribut}
\slide{62}
\subsection{Schattierungsarten}
\slide{63}
\subsection{Programmeinbindung der Vordergrundfarbe}
\subsubsection*{Befehlsfolge:}
\slide{64}

\section{Pufferobjekte}
\slide{65}
\unimptnt{
\slide{66}
\slide{67}
}
\subsection{Programmbeispiele}
\subsubsection*{Interpolation von Eckpunkten und Farben zweier Dreiecke}
\slide{68}
\slide{69}
\subsubsection*{Zeichenvarianten eines Dreiecks}
\slide{70}
\subsubsection*{Indexierte Zeichnung eines Würfels}
\slide{71}
\slide{72}

\unimptnt{
\section{Polygone und Netze}
\subsection{Quadriken}
\slide{73}
\subsection{Evaluatoren}
\slide{74}

\section{Funktionsreferenz}
\slide{75}
\slide{76}
\slide{77}
\slide{78}
}
\chapter{OpenGL: Pixel und Puffer}
\unimptnt{
\slide{79}
}
\section{Pufferstrukturen}
\slide{80}
\section{Pufferoperationen}
\slide{81}
\begin{itemize}
\item glClearColor(): Hintergrundfarbe, zu Beginn der display() Funktion, es sei denn für Effekte
\item glClearDepth(): Tiefenpuffer , zu Beginn der display() Funktion, es sei denn für Effekte
\end{itemize}
Maskieren wird nach dem Fragmentshader verwendet.
\begin{itemize}
\item Scissor-Test: In der Regel Rechtecke (Schnittrechteck)
\item Multi-Sample-Operations: Subpixel
\item Stencil-test: Maske/Schablone
\item Depht Buffer Test: verdeckte pixel werden nicht gerendert
\item Blending: später
\item Logic Operations: z.B. Transparenz
\item Dithering: Räumliche/Farbliche Auflösung
\end{itemize}
\subsection{Tests und Operationen für Fragmente}
\subsubsection{Scissor-Test, Multisampling-Fragment-Operationen, Stencil-Test}
\slide{82}
glScissor(x,y,w,h) (Ursprung, Länge, Höhe: Nur alles was in diesem Feld enthalten ist wird angezeigt
\subsubsection{Depth-Test, Dithering, Logic}
\slide{83}
GL\_ LESS Objekte die kleiner sind als der eingestellte wert werden nicht gerendert
\begin{lstlisting}[language=C++]
init(){
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(func);
	glPolygonOffset(factor units);
}

display()
{
	glClear(GL_DEPTH_BIT);
	...
}
\end{lstlisting}
mit glPolygonOffset() kann sichergestellt werden das eine Kante um ein Objekt sichtbar wird.
\subsubsection{Blending}
\slide{84}
Transparenz: GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA\\
Beispiel:$\alpha_q = 0.7 \Rightarrow 0.5*0.7+0.2*0.3 = 0.$
\unimptnt{
\subsubsection*{Funktionen für Blending}
\slide{85}
\subsubsection{Verdeckungsabfrangen, bedingtes Rendern}
\slide{86}
\subsection{Antialiasing}
\slide{87}
\subsubsection{Multisampling}
\slide{88}
}
\subsubsection*{Programmbeispiel}
Räumlich beschränkte / tiefengerechte / transparente Ausgabe:
\slide{89}
\unimptnt{
\section{Framebuffer Objekte}
\slide{90}
\section{Multiple Renderbuffer}
\slide{91}
\section{Lesen und Kopieren von Pixeldaten}
\slide{92}
\subsection*{Beispiel}
Zugriff auf Renderbuffer:
\slide{93}

\section{Funktionsreferenz}
\slide{94}
\slide{95}
\slide{96}
}

\chapter{OpenGL: Ansicht und Transformation}
\unimptnt{
\slide{97}
}

\section{Modelle und Operationen}
\unimptnt{
\slide{98}
}

\subsection{Kamera Analogie und Geometrie Pipeline}
\slide{99}
\unimptnt{
\subsection{Vektoren und Matrizen}
\slide{100}
}
\subsection{Koordinatensysteme}
\slide{101}

\section{Transformation}
\slide{102}

\section{Projektion}
\slide{103}

\section{Viewport}
\slide{104}

\section{Matrizen}
\slide{105}
\unimptnt{
\slide{106}
}
\section{Bibliotheksoperationen}
\slide{109}

\subsection{Programmbeispiele}
\slide{110}
\slide{111}

\section{Transformationsrückkopplung}
\unimptnt{
\slide{112}
\subsection{Programmbeispiel}
\slide{113}

\section{Funktionsreferenz}
\slide{114}
\slide{115}
\slide{116}
}

% bis 190


%\newpage
%\printbibliography

\end{document}