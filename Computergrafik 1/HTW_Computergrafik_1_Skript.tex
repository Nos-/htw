\newcommand{\customDir}{../}
\input{\customDir .LaTeX_master/LaTeX_master_setup.sty}

%\setboolean{twosided}{true}
%\setCustomDocumentClass{scrartcl}
%\setCustomDesign{htw}
\setCustomSlidePath{Vorlesung/CG1-01-15}

\setCustomTitle{Computergrafik 1}
\setCustomSubtitle{Vorlesungsskript}
\setCustomAuthor{Falk-Jonatan Strube}
%\setCustomNoteA{TitlepageNoteBeforeAuthor}
\setCustomNoteB{Vorlesung von Prof. Dr.-Ing. habil. Oertel}

%\setcustomSignature{\footnotesize{\textcolor{darkgray}{Mitschrift von\\ \customAuthor}}	% Formatierung der Signatur in der Fußzeile
%\setcustomTitleAuthor{\textcolor{darkgray}{Mitschrift von #1}}	% Formatierung des Autors auf dem Titelblatt

\input{\customDir .LaTeX_master/LaTeX_master.sty}
\input{\customDir .LaTeX_master/LaTeX_master_macros.sty}

%\bibliography{\customDir .Literatur/HTW_Literatur.bib}

\begin{document}

%\selectlanguage{english}
\maketitle
\newpage
\tableofcontents
\newpage

\chapter*{Vorbemerkung}
Prüfung: alle Unterlagen erlaubt (Skripte, Bücher usw.)\\
2 Teile: 1/2 Praxis (erste Hälfte der VL), 1/2 „Theorie“ (zweite Hälfte der VL)\\
Belegabgabe: Ende der Vorlesungszeit (03.02.2016), Vorabgabe (vorm Einreichen) im Praktikum
% Passwort: WSEM2016
%\slideScale{2}

Folien mit +: wichtige Folien
\chapter*{Grundbegriffe}
\slideScale{3}
\section*{Systematisierung}
\slideScale{4}

\chapter{OpenGL: Anwendung und Programmierung}
\slideScale{5}
\section{Systemarchitektur}
\slideScale{6}
\subsection{Interaktive generative grafische Systeme}
\slideScale{7}
\subsection{Grafische Datenstrukturen}
\slideScale{8}
\subsection{Weg und Ziel}
\slideScale{9}
3. Bild: Schattierung (keine Schattenbildung, sondern „Einfärbung“ von Seiten)

\section{OpenGL}
\slideScale{10}
\subsection{Versionen}
\slideScale{11}
\subsection{OpenGL Core Profile}
\slideScale{12}
Eckpunkte -> Vertex Shader -> Fragment Shader -> Framebuffer
\subsection{Grafik-Bibliotheken}
\slideScale{13}
\subsection{Initialisierung}
\slideScale{14}

\section{Renderpipeline}
\slideScale{15}
\subsection{Sequentielle Struktur}
\slideScale{16}
\slideScale{17}

\section{Rahmenprogramm}
\subsection{Client-Seite}
\slideScale{18}
\slideScale{19}
\subsection{Server-Seite}
\slideScale{20}

\section{Hauptprogramm}
\subsection{Sprachsyntax}
\slideScale{21}

\section{Funktionsreferenz}
\subsection{Funktionen GL}
\slideScale{22}
\slideScale{25}
\subsection{Funktionen GLUT}
\slideScale{23}
\slideScale{24}

\chapter{OpenGL: Shader und Programmierung}
\slideScale{28}
\section{Vorgehensweise}
\slideScale{29}
Fragment-Shader als Rasterisierung eines Bildes (bspw. Vektor-Strich von A nach B) und dann Zuweisung der Farbe den entsprechenden Rasterelementen/Pixel\\
Vertex-Shader guckt sich dem entgegen Eckpunkte an.
\section{Shader-Einbindung}
\slideScale{30}
\subsection{Programmbeispiele}
\slideScale{32}
\subsection{Funktionen}
\slideScale{31}

\section{Rasterisierung und obligatorischer Shader}
\subsection{Rasterisierung}
\slideScale{33}
\subsection{Vertex-Shader}
\slideScale{34}
\subsection{Fragment-Shader}
\slideScale{35}

\subsection{Beispiele}
\slideScale{36}

\section{Shader-Sprache}
\slideScale{37}
\subsection{Operatoren und Ausdrücke}
\slideScale{38}
\slideScale{39}
\subsection{Qualifikatoren}
\slideScale{40}
\slideScale{41}
\slideScale{42}

\subsection{Vordefinierte Funktionen}
\slideScale{43}
\slideScale{44}

\subsection{Vordefinierte Variablen}
\slideScale{45}
\slideScale{46}

\subsection{Programmbeispiele}
\slideScale{47}
\slideScale{48}

\section{Programm- und Datenübergabe}
\slideScale{49}
\subsection{Interface Blöcke}
\slideScale{50}

\section{Funktionsreferenz}
\slideScale{51}
\slideScale{52}

\chapter{OpenGL: Zeichnung und Daten}
\slideScale{54}

\section{Vorgehensweise}
\slideScale{55}

\section{Zeichenprimitive}
\slideScale{56}

2,5\,D Geometrie: die 3. Dimension nur senkrecht zu einer Fläche (bspw. Bildschirm)

\subsection{Punkte, Linien}
\slideScale{57}

\subsection{Dreiecke}
\slideScale{58}

\subsection{Darstellungsattribute}
\slideScale{59}

\subsection{Programmeinbindung der Zeichenprimitive}
\subsubsection*{Befehlsfolge:}
\slideScale{60}

\section{Zeichenfarben}
\slideScale{61}
zeigt NUR im Fragmentshader Wirkung
\subsection{Farbe als Attribut}
\slideScale{62}
\subsection{Programmeinbindung der Vordergrundfarbe}
\subsubsection*{Befehlsfolge:}
\slideScale{63}

\section{Pufferobjekte}
\slideScale{64}
\slideScale{65}
\slideScale{66}
\subsection{Programmbeispiele}
\subsubsection*{Interpolation von Eckpunkten und Farben zweier Dreiecke}
\slideScale{67}
\slideScale{68}
\subsubsection*{Zeichenvarianten eines Dreiecks}
\slideScale{69}
\subsubsection*{Indexierte Zeichnung eines Würfels}
\slideScale{70}
\slideScale{71}

\section{Polygone und Netze}
\subsection{Quadriken}
\slideScale{72}
\subsection{Evaluatoren}
\slideScale{73}

\section{Funktionsreferenz}
\slideScale{74}
\slideScale{75}
\slideScale{76}
\slideScale{77}

\chapter{OpenGL: Pixel und Puffer}
\slideScale{78}
\section{Pufferstrukturen}
\slideScale{79}
\section{Pufferoperationen}
\slideScale{80}
\begin{itemize}
\item glClearColor(): Hintergrundfarbe, zu Beginn der display() Funktion, es sei denn für Effekte
\item glClearDepth(): Tiefenpuffer , zu Beginn der display() Funktion, es sei denn für Effekte
\end{itemize}
Maskieren wird nach dem Fragmentshader verwendet.
\begin{itemize}
\item Scissor-Test: In der Regel Rechtecke (Schnittrechteck)
\item Multi-Sample-Operations: Subpixel
\item Stencil-test: Maske/Schablone
\item Depht Buffer Test: verdeckte pixel werden nicht gerendert
\item Blending: später
\item Logic Operations: z.B. Transparenz
\item Dithering: Räumliche/Farbliche Auflösung
\end{itemize}
\subsection{Tests und Operationen für Fragmente}
\subsubsection{Scissor-Test, Multisampling-Fragment-Operationen, Stencil-Test}
\slideScale{81}
glScissor(x,y,w,h) (Ursprung, Länge, Höhe: Nur alles was in diesem Feld enthalten ist wird angezeigt
\subsubsection{Depth-Test, Dithering, Logic}
\slideScale{82}
GL\_ LESS Objekte die kleiner sind als der eingestellte wert werden nicht gerendert
\begin{lstlisting}[language=C++]
init(){
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(func);
	glPolygonOffset(factor units);
}

display()
{
	glClear(GL_DEPTH_BIT);
	...
}
\end{lstlisting}
mit glPolygonOffset() kann sichergestellt werden das eine Kante um ein Objekt sichtbar wird.
\subsubsection{Blending}
\slideScale{83}
Transparenz: GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA\\
Beispiel:$\alpha_q = 0.7 \Rightarrow 0.5*0.7+0.2*0.3 = 0.$
\subsubsection*{Funktionen für Blending}
\slideScale{84}
\subsubsection{Verdeckungsabfrangen, bedingtes Rendern}
\slideScale{85}
\subsection{Antialiasing}
\slideScale{86}
\subsubsection{Multisampling}
\slideScale{87}
\subsubsection*{Programmbeispiel}
Räumlich beschränkte / tiefengerechte / transparente Ausgabe:
\slideScale{88}
\section{Framebuffer Objekte}
\slideScale{89}
\section{Multiple Renderbuffer}
\slideScale{90}
\section{Lesen und Kopieren von Pixeldaten}
\slideScale{91}
\subsection*{Beispiel}
Zugriff auf Renderbuffer:
\slideScale{92}

\section{Funktionsreferenz}
\slideScale{93}
\slideScale{94}
\slideScale{95}

\chapter{OpenGL: Ansicht und Transformation}
\slideScale{96}

\section{Modelle und Operationen}
\slideScale{97}

\subsection{Kamera Analogie und Geometrie Pipeline}
\slideScale{98}
\subsection{Vektoren und Matrizen}
\slideScale{99}
\subsection{Koordinatensysteme}
\slideScale{100}

\section{Transformation}
\slideScale{101}

\section{Projektion}
\slideScale{102}

\section{Viewport}
\slideScale{103}

\section{Matrizen}
\slideScale{104}
\slideScale{105}

\section{Bibliotheksoperationen}
\slideScale{108}

\subsection{Programmbeispiele}
\slideScale{109}
\slideScale{110}

\section{Transformationsrückkopplung}
\slideScale{111}
\subsection{Programmbeispiel}
\slideScale{112}

\section{Funktionsreferenz}
\slideScale{113}
\slideScale{114}
\slideScale{115}



%\newpage
%\printbibliography

\end{document}